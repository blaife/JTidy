# 算法 4.0

## 1. 排序算法

> 算法的实现效率取决于比较的次数
> 大部分的增长数量级都是线性对数或者平方级别
### 1.1 初级排序算法

#### 1.1.1 选择排序

1. 找到数组中最小的那个元素
2. 将它和数组中的第一个元素交换位置
3. 再次，在剩下的元素中找到最小的元素

#### 1.1.2 插入排序

将其余所有元素都在插入之前向右移动一位

如果数组中倒置的数量小于数据大小的某个倍数，我们说这个数据是部分有序的
典型的部分有序的数据：
 数组中的每个元素距离它的最终位置都不远
 一个有序的大数组接一个小数组
 数组中之后几个元素的位置不正确

平均：比较次数：(N^2)/4  交换次数：(N^2)/4
最坏：比较次数：(N^2)/2  交换次数：(N^2)/2
最好：比较次数：N-1      交换次数：0

***改进，将较大的元素都向右移动而不总是交换两个元素***

#### 1.1.3 希尔排序

> 希尔排序 - 一种基于插入排序的快速排序算法，也称为 `缩小增量排序`

> 希尔排序是把记录按下标的一定增量分组，对每组使用直接插入排序算法排序；随着增量逐渐减少，每组包含的关键词越来越多，当增量减至1时，整个文件恰被分成一组，算法便终止。

交换不相邻的元素以对数组的局部进行排序，并最终用插入排序将局部有序的数组排序，**任意间隔为 h 的元素都是有序的**

希尔排序是唯一无法准确描述其对于乱序的数组的性能特征的排序方法

注意：着重在于任意间隔有序以及增量分组

![希尔排序](file/希尔排序.png)

### 1.2 归并排序

要将一个数组排序，可以先（递归地）将它分成两半分别排序，然后将结果归并起来。  

归并排序吸引人的性质是它能保证将任意长度为 N 的数组排序所需时间和 NlogN 成正比；  
主要的缺点则是它所需的额外空间和 N 成正比  

#### 1.2.1 原地归并排序的抽象方法

将涉及的所有元素都复制到一个辅助数组中，再将归并的结果放回原数组中  
两端比较，取小值进行写入,详见 `OnSideSort`

#### 1.2.2 自顶向下的归并排序

自定向下的归并排序就是在原地归并排序的基础上执行，对于一个大的数据对象，
将其不断拆分，进行合并，可以对小规模子数组使用合适的排序方法以提高算法性能。

#### 1.2.3 自底向上的归并排序

自底向上的归并排序就是先归并哪些微型数组，然后再承兑归并得到的子数组，直到将整个数组归并到一起

### 1.3 快速排序

快速排序可能是应用最广泛的排序算法了，

它的优点有：
- 实现简单
- 适用于各种不同的输入数据且在一般应用中比其他算法要快得多
- 原地排序（只需要一个很小的辅助栈）且时间与 NlgN 成正比

缺点：
- 非常脆弱

#### 1.3.1 基本算法

快速排序是一种分治的算法，她与归并排序是互补的，对比如下：

| 归并                                                         | 快排                                       |
| :----------------------------------------------------------- | :----------------------------------------- |
| 将数组分成两个子数组分别排序，并将有序的子数组归并以将整个数组排序 | 当两个子数组都有序时整个数组也就自然有序了 |
| 递归调用发生在处理整个数组之前                               | 递归调用发生在处理整个数组之后             |
| 一个数组被等分成两半                                         | 切分的位置取决于数组的内容                 |







### 1.4 优先队列

### 1.5 总结

## 2. 查找

### 2.1 符号表
### 2.2 二叉查找树
### 2.3 平衡查找树
### 2.4 散列表
### 2.5 总结

## 3. 图
### 3.1 无向图
### 3.2 有向图
### 3.3 最小生成树
### 3.4 最短路径

## 4. 字符串
### 4.1 字符串排序
### 4.2 单词查找树
### 4.3 子字符换查找
### 4.4 正则表达式
### 4.5 数据压缩
